{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 TimesNewRomanPS-BoldMT;\f1\froman\fcharset0 TimesNewRomanPSMT;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11480\viewh6660\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs30 \cf0 Did your graph match your runtime analysis expectations?\

\f1\b0 In general, the graph aligns with my runtime analysis expectations. When looking at the CPU sequential curve, it demonstrates the fastest runtime among all approaches for small array lengths, but as the length increases, it no longer runs as fast as the recursive doubling approach. Regarding the GPU naive curve, it increases as the array length grows, and the rate of increase also accelerates. \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8012\tx8640\pardirnatural\partightenfactor0
\cf0 While the overall trend as well as comparisons among the three curves match my expectation, the shape of the CPU sequential and GPU recursive doubling curve differs slightly. Because I\'92m scaling the y-axis (execution time in ns) using a logarithm with base 10, the CPU sequential curve should exhibit a parabola instead, while the GPU recursive doubling curve should appear more linear. \
\

\f0\b What went well with this assignment?\

\f1\b0 Understanding the requirements of this assignment was quite easy. \
\

\f0\b What was difficult?\

\f1\b0 Because in A2, we were given the code for stencil, and the task primarily focused on understanding it, jumping straight into coding the three algorithms this time was a little challenging, especially the recursive doubling one. \
\

\f0\b How would you approach differently?\

\f1\b0 Again, I would consider starting even earlier. }